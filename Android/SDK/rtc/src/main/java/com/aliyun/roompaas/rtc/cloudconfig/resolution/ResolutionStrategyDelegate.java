package com.aliyun.roompaas.rtc.cloudconfig.resolution;import android.support.annotation.NonNull;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONException;import com.alibaba.fastjson.TypeReference;import com.aliyun.roompaas.base.cloudconfig.IKeys;import com.aliyun.roompaas.base.cloudconfig.base.BaseCloudConfigDelegate;import com.aliyun.roompaas.base.log.Logger;import com.aliyun.roompaas.base.util.ThreadUtil;import com.aliyun.roompaas.base.util.Utils;import com.aliyun.roompaas.rtc.exposable.RtcStreamConfig;import java.lang.ref.Reference;import java.lang.ref.WeakReference;import java.lang.reflect.Type;import java.util.HashSet;import java.util.List;import java.util.Set;import java.util.concurrent.ScheduledFuture;import java.util.concurrent.TimeUnit;/** * Created by KyleCe on 2022/5/17 */public class ResolutionStrategyDelegate extends BaseCloudConfigDelegate implements IResolutionStrategy {    public static final String TAG = "ResolutionStrategyMgr";    public static boolean TURN_ON_DYNAMIC_RESOLUTION_ADJUST;    private static final float H_W_RATIO_AVOID_ENGINE_PICTURE_SCALE_BUG = 480 / 640f;    private List<ResolutionBean> resolutionsOfCloudConfig;    private final Reference<IResolutionAdapter> adapterRef;    private final Set<String> remoteOnlineIds;    private final Set<String> remoteOfflineIds;    private ResolutionBean appliedResolution;    private ScheduledFuture<?> adjustResolutionFuture;    private static final long ADJUST_ACTION_PENDING_DURATION = 1200;    public ResolutionStrategyDelegate(IResolutionAdapter adapter) {        this.adapterRef = new WeakReference<>(adapter);        remoteOnlineIds = new HashSet<>();        remoteOfflineIds = new HashSet<>();    }    @Override    protected String singlePrimaryKey(){        return IKeys.Slaver.slaveCameraResolutionStrategyMobile;    }    @Override    protected void singlePrimaryKeyResultFetched(String result) {        try {            Type type = new TypeReference<List<ResolutionBean>>() {            }.getType();            resolutionsOfCloudConfig = JSON.parseObject(result, type);        } catch (JSONException e) {            e.printStackTrace();        }    }    @Override    public void onRemoteUserOnLineNotify(String uid) {        adjustResolutionIfVital(uid, true);    }    @Override    public void onRemoteUserOffLineNotify(String uid) {        adjustResolutionIfVital(uid, false);    }    private void adjustResolutionIfVital(String uid, boolean true4Online) {        if (!TURN_ON_DYNAMIC_RESOLUTION_ADJUST) {            Logger.e(TAG, "adjustResolutionIfVital: end--invalid param: !TURN_ON_DYNAMIC_RESOLUTION_ADJUST");            return;        }        final IResolutionAdapter adapter = Utils.getRef(adapterRef);        if (adapter == null) {            Logger.e(TAG, "adjustResolutionIfVital: end--invalid param: empty");            return;        }        if (!adapter.isChannelJoined()) {            Logger.e(TAG, "adjustResolutionIfVital: end--invalid param: !adapter.isChannelJoined()");            reset();            return;        }        if (Utils.isEmpty(resolutionsOfCloudConfig)) {            Logger.e(TAG, "adjustResolutionIfVital: end--invalid param: empty resolutionsOfCloudConfig");            return;        }        if (true4Online) {            remoteOnlineIds.add(uid);            remoteOfflineIds.remove(uid);        } else {            remoteOnlineIds.remove(uid);            remoteOfflineIds.add(uid);        }        final int onlineCount;        if ((onlineCount = remoteOnlineIds.size() + 1/*user self as one*/) == 1) {            Logger.e(TAG, "adjustResolutionIfVital: end--invalid param: empty onlineIds");            return;        }        Utils.cancel(adjustResolutionFuture);        adjustResolutionFuture = ThreadUtil.schedule(                new Runnable() {                    @Override                    public void run() {                        adjustProcess(adapter, onlineCount);                    }                }                , ADJUST_ACTION_PENDING_DURATION, TimeUnit.MILLISECONDS);    }    private void adjustProcess(@NonNull IResolutionAdapter adapter, int onlineCount) {        ResolutionBean standard = null;        for (ResolutionBean bean : resolutionsOfCloudConfig) {            if (onlineCount >= bean.onlineCount) {                standard = bean;            }        }        if (standard == null || (appliedResolution != null && appliedResolution.onlineCount == standard.onlineCount)) {            Logger.e(TAG, "adjustResolutionIfVital: end--invalid param: empty standard || appliedResolution same");            return;        }        appliedResolution = standard;        int width = standard.width;        int height = (int) (width * H_W_RATIO_AVOID_ENGINE_PICTURE_SCALE_BUG);        adapter.updateVideoEncodeConfig(new RtcStreamConfig(width, height));        Logger.i(TAG, "adjustResolutionIfVital: width=" + width + " , height=" + height);    }    @Override    public void reset() {        Utils.clear(remoteOnlineIds, remoteOfflineIds);        appliedResolution = null;        Utils.cancel(adjustResolutionFuture);    }    @Override    public void destroy() {        super.destroy();        reset();        Utils.clear(resolutionsOfCloudConfig);        Utils.clear(adapterRef);    }}
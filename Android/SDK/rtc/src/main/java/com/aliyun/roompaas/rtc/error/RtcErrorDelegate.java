package com.aliyun.roompaas.rtc.error;import android.content.Context;import android.support.annotation.IntDef;import android.support.annotation.NonNull;import com.aliyun.roompaas.base.IDestroyable;import com.aliyun.roompaas.base.IReset;import com.aliyun.roompaas.base.base.Producer;import com.aliyun.roompaas.base.log.Logger;import com.aliyun.roompaas.base.tools.retry.IRetry;import com.aliyun.roompaas.base.tools.retry.RetryBot;import com.aliyun.roompaas.base.util.CommonUtil;import com.aliyun.roompaas.base.util.NetUtils;import com.aliyun.roompaas.base.util.Utils;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;/** * Created by KyleCe on 2022/5/29 */public class RtcErrorDelegate implements IDestroyable, IReset {    public static final String TAG = "RtcErrorDelegate";    private Context context;    private final IRetry<Integer> joinChannelRetry;    private final IRetry<Integer> publishVideoRetry; // process sync directly    //    private final IRetry subscribeRetry; // SDK process by default    private boolean toastOn = true;    private long toastLastTS;    private long toastIntervalInSeconds = 5;    @Retention(RetentionPolicy.SOURCE)    @IntDef({Type.JOIN_CHANNEL, Type.PUBLISH_VIDEO, Type.SUBSCRIBE})    public @interface Type {        int JOIN_CHANNEL = 0;        int PUBLISH_VIDEO = 1;        int SUBSCRIBE = 2;    }    public RtcErrorDelegate(@NonNull Context context) {        this.context = context.getApplicationContext();        this.joinChannelRetry = new RetryBot<>();        this.publishVideoRetry = new RetryBot<>();    }    public int takeAction(@Type int type, @NonNull Producer<Integer> act) {        Logger.i(TAG, "takeAction: " + type);        switch (type) {            case Type.JOIN_CHANNEL:                joinChannelRetry.setAction(act);                joinChannelRetry.reset();                break;            case Type.PUBLISH_VIDEO:                publishVideoRetry.setAction(act);                publishVideoRetry.reset();            case Type.SUBSCRIBE:            default:                break;        }        return act.produce();    }    public void error(int code, String msg) {        Logger.i(TAG, "error: " + code + ",msg=" + msg);        if (IRtcErr.Network.CODE_SET.contains(code)) {            toastIfPossible(IRtcErr.Network.S_CHECK_NET);        } else if (IRtcErr.JoinChannel.CODE_SET.contains(code)) {            joinChannelRetry.actionFail();        } else if (IRtcErr.Publish.CODE_SET.contains(code)) {            publishVideoRetry.actionFail();        } else if (IRtcErr.Unrecoverable.CODE_SET.contains(code)) {            toastIfPossible(IRtcErr.Unrecoverable.S_REENTER);        } else {            Logger.i(TAG, "error: unable to auto process");        }    }    public void actionSuccess(@Type int type) {        Logger.i(TAG, "actionSuccess: " + type);        switch (type) {            case Type.JOIN_CHANNEL:                joinChannelRetry.actionSuccess();                break;            case Type.PUBLISH_VIDEO:                publishVideoRetry.actionSuccess();                break;            case Type.SUBSCRIBE:            default:                break;        }    }    public void actionFail(@Type int type) {        Logger.i(TAG, "actionFail: " + type);        switch (type) {            case Type.JOIN_CHANNEL:                joinChannelRetry.actionFail();                break;            case Type.PUBLISH_VIDEO:                publishVideoRetry.actionFail();                break;            case Type.SUBSCRIBE:            default:                break;        }    }    public int runOnDirectRetry(Producer<Integer> producer) {        return runOnDirectRetry(producer, false);    }    public int runOnDirectRetry(Producer<Integer> producer, boolean ignoreNetwork) {        Logger.i(TAG, "runOnDirectRetry: " + ignoreNetwork);        int retryTime = 0;        int res = -1;        boolean netSuit = ignoreNetwork | NetUtils.isNetConnected();        while (retryTime++ < IRetry.DEFAULT_TIMES_LIMIT && netSuit) {            res = producer.produce();            if (res >= 0) {                break;            }        }        if (res < 0 && !ignoreNetwork && !NetUtils.isNetConnected()) {            toastIfPossible(IRtcErr.Network.S_CHECK_NET);        }        return res;    }    public void configErrorToast(boolean trueForOn, long shortestIntervalInSeconds) {        Logger.i(TAG, "configErrorToast: trueForOn=" + trueForOn + " ,shortestIntervalInSeconds= " + shortestIntervalInSeconds);        this.toastOn = trueForOn;        this.toastIntervalInSeconds = shortestIntervalInSeconds;    }    public void toastIfPossible(String msg) {        Logger.i(TAG, "toastIfPossible: " + msg);        if (!toastOn || System.currentTimeMillis() - toastLastTS < toastIntervalInSeconds) {            Logger.e(TAG, "toastIfPossible: end--invalid param: toastOn =" + toastOn + ", interval=" + toastIntervalInSeconds);            return;        }        toastLastTS = System.currentTimeMillis();        CommonUtil.showToast(context, msg);    }    @Override    public void reset() {        Utils.reset(joinChannelRetry);    }    @Override    public void destroy() {        Utils.destroy(joinChannelRetry);    }}
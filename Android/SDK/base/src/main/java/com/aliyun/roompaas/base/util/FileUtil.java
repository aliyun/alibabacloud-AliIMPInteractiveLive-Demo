package com.aliyun.roompaas.base.util;import android.support.annotation.WorkerThread;import android.text.TextUtils;import com.aliyun.roompaas.base.log.Logger;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.util.Enumeration;import java.util.zip.ZipEntry;import java.util.zip.ZipFile;import java.util.zip.ZipInputStream;/** * Created by KyleCe on 2022/6/14 */public class FileUtil {    public static final String TAG = "FileUtil";    @WorkerThread    public static int unzip(String srcFileName, String destDirPath) throws RuntimeException {        Logger.i(TAG, "unZip destDirPath：" + destDirPath);        int BUFFER_SIZE = 1024 * 2;        File srcFile = new File(srcFileName);        if (!srcFile.exists()) {            Logger.i(TAG, "unZip:" + srcFile.getPath() + "所指文件不存在");            return -1;        }        // 开始解压        ZipFile zipFile = null;        try {            zipFile = new ZipFile(srcFile);            Enumeration<?> entries = zipFile.entries();            while (entries.hasMoreElements()) {                ZipEntry entry = (ZipEntry) entries.nextElement();//                Logger.i(TAG, "unZip:" + "解压" + entry.getName());                // 如果是文件夹，就创建个文件夹                if (entry.isDirectory()) {                    String dirPath = destDirPath + File.separator + entry.getName();                    File dir = new File(dirPath);                    dir.mkdirs();                } else {                    // 如果是文件，就先创建一个文件，然后用io流把内容copy过去                    File targetFile = new File(destDirPath + File.separator + entry.getName());                    // 保证这个文件的父文件夹必须要存在                    if (!targetFile.getParentFile().exists()) {                        targetFile.getParentFile().mkdirs();                    }                    targetFile.createNewFile();                    // 将压缩文件内容写入到这个文件中                    InputStream is = zipFile.getInputStream(entry);                    FileOutputStream fos = new FileOutputStream(targetFile);                    int len;                    byte[] buf = new byte[BUFFER_SIZE];                    while ((len = is.read(buf)) != -1) {                        fos.write(buf, 0, len);                    }                    // 关流顺序，先打开的后关闭                    IOUtil.close(fos, is);                }            }            return 1;        } catch (Throwable e) {            e.printStackTrace();            Logger.e(TAG, "unZip:" + "解压失败，e:" + e);            return -1;        } finally {            IOUtil.close(zipFile);        }    }    private static final int BUFFER_SIZE = 8192;    protected static byte buf[] = new byte[BUFFER_SIZE];    /**     * Unzip a inputstream data to the target path. if the path is exists, and     * is not a dir will delete the path, and recreate it. if the path is not     * exists, create the path. if the inputstream is not a package contain some     * files and dirs, will out put the data to the target and create all the     * files and dirs and the targetPath.     *     * @param is         is InputStream contain the files data.     * @param targetPath targetPath must be end with system path seprator     * @return true if unzip successflly, false if failed. false if the     * inputstream is null or the targetPath is null or the targetPath     * is empty string.     */    public static boolean unZipFile(InputStream is, String targetPath) {        if (is == null || TextUtils.isEmpty(targetPath)) {            return false;        }        try {            checkDirectory(targetPath);            extZipFile(is, targetPath);            is.close();            return true;        } catch (Exception e) {            e.printStackTrace();        }        return false;    }    /**     * Unzip a source to the targetPath, is similar with the     * UnZipFile(InputStream is, String targetPath)     *     * @param source     source file to unzip     * @param targetPath targetPath to place out files.     * @return true if successfully, false if failed. false if the source file     * is not exists.     */    public static boolean unZipFile(String source, String targetPath) {        File file = new File(source);        if (!file.exists()) {            return false;        }        try {            return unZipFile(new FileInputStream(file), targetPath);        } catch (Exception e) {        }        return false;    }    private static boolean checkDirectory(String dir) {        File dirObj = new File(dir);        if (dirObj.exists()) {            if (!dirObj.isDirectory()) {                dirObj.delete();            }            return false;        }        if (!dirObj.exists()) {            dirObj.mkdirs();        }        return true;    }    private static void extZipFile(InputStream is, String extPlace) {        ZipInputStream in = new ZipInputStream(is);        ZipEntry entry = null;        try {            while ((entry = in.getNextEntry()) != null) {                final String fullName = extPlace + File.separator + entry.getName();                if (entry.isDirectory()) {                    File file = new File(fullName);                    file.mkdirs();                } else {                    doOutputFile(in, fullName);                    in.closeEntry();                }            }        } catch (IOException e) {        } finally {            in = null;        }    }    /**     * get the file list in the inputstream data     *     * @param is the inputstream data     * @return the file list contain in the inputstream. if the is is null     * return null     */    private static void doOutputFile(InputStream is, String filename)            throws IOException, FileNotFoundException {        FileOutputStream os = new FileOutputStream(filename);        BufferedOutputStream bos = new BufferedOutputStream(os, BUFFER_SIZE);        int len;        while ((len = is.read(buf, 0, BUFFER_SIZE)) > 0) {            bos.write(buf, 0, len);        }        bos.flush();        IOUtil.close(bos, os);    }}